{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Julia\\\\Desktop\\\\permissioning-smart-contracts-master\\\\permissioning-smart-contracts-master\\\\src\\\\context\\\\accountData.tsx\";\nimport React, { createContext, useContext, useEffect, useState, useMemo } from 'react';\nimport { accountRulesFactory } from '../chain/contracts/AccountRules';\nimport { useNetwork } from './network';\nconst AccountDataContext = createContext(undefined);\n\nconst loadAccountData = (accountRulesContract, setAccountList, setAccountReadOnly) => {\n  if (accountRulesContract === undefined) {\n    setAccountList([]);\n    setAccountReadOnly(undefined);\n  } else {\n    accountRulesContract.functions.isReadOnly().then(isReadOnly => setAccountReadOnly(isReadOnly));\n    accountRulesContract.functions.getSize().then(listSize => {\n      const listElementsPromises = [];\n\n      for (let i = 0; listSize.gt(i); i++) {\n        listElementsPromises.push(accountRulesContract.functions.getByIndex(i));\n      }\n\n      Promise.all(listElementsPromises).then(responses => {\n        setAccountList(responses.map(address => ({\n          address\n        })));\n      });\n    });\n  }\n};\n/**\n * Provider for the data context that contains the account list\n * @param {Object} props Props given to the AccountDataProvider\n * @return The provider with the following value:\n *  - accountList: list of permitted accounts from Account Rules contract\n *  - setAccountList: setter for the allowlist state\n */\n\n\nexport const AccountDataProvider = props => {\n  const [accountList, setAccountList] = useState([]);\n  const [accountReadOnly, setAccountReadOnly] = useState(undefined);\n  const [accountRulesContract, setAccountRulesContract] = useState(undefined);\n  const value = useMemo(() => ({\n    accountList: accountList,\n    setAccountList: setAccountList,\n    accountReadOnly,\n    setAccountReadOnly,\n    accountRulesContract,\n    setAccountRulesContract\n  }), [accountList, setAccountList, accountReadOnly, setAccountReadOnly, accountRulesContract, setAccountRulesContract]);\n  const {\n    accountIngressContract\n  } = useNetwork();\n  useEffect(() => {\n    if (accountIngressContract === undefined) {\n      setAccountRulesContract(undefined);\n    } else {\n      accountRulesFactory(accountIngressContract).then(contract => {\n        setAccountRulesContract(contract);\n        contract.removeAllListeners('AccountAdded');\n        contract.removeAllListeners('AccountRemoved');\n        contract.on('AccountAdded', (success, account, event) => {\n          if (success) {\n            loadAccountData(contract, setAccountList, setAccountReadOnly);\n          }\n        });\n        contract.on('AccountRemoved', (success, account, event) => {\n          if (success) {\n            loadAccountData(contract, setAccountList, setAccountReadOnly);\n          }\n        });\n      });\n    }\n  }, [accountIngressContract, setAccountList, setAccountReadOnly]);\n  return /*#__PURE__*/React.createElement(AccountDataContext.Provider, Object.assign({\n    value: value\n  }, props, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 10\n    }\n  }));\n};\n/**\n * Fetch the appropriate account data on chain and synchronize with it\n * @return {Object} Contains data of interest:\n *  - dataReady: true if isReadOnly and account allowlist are correctly fetched,\n *  false otherwise\n *  - userAddress: Address of the user\n *  - isReadOnly: Account contract is lock or unlock,\n *  - allowlist: list of permitted accounts from Account contract,\n */\n\nexport const useAccountData = () => {\n  const context = useContext(AccountDataContext);\n\n  if (!context) {\n    throw new Error('useAccountData must be used within an AccountDataProvider.');\n  }\n\n  const {\n    accountList,\n    setAccountList,\n    accountReadOnly,\n    setAccountReadOnly,\n    accountRulesContract\n  } = context;\n  useEffect(() => {\n    loadAccountData(accountRulesContract, setAccountList, setAccountReadOnly);\n  }, [accountRulesContract, setAccountList, setAccountReadOnly]);\n  const formattedAccountList = useMemo(() => {\n    return accountList.map(account => ({ ...account,\n      identifier: account.address.toLowerCase(),\n      status: 'active'\n    })).reverse();\n  }, [accountList]);\n  const dataReady = useMemo(() => {\n    return accountRulesContract !== undefined && accountReadOnly !== undefined && accountList !== undefined;\n  }, [accountRulesContract, accountReadOnly, accountList]);\n  return {\n    dataReady,\n    allowlist: formattedAccountList,\n    isReadOnly: accountReadOnly,\n    accountRulesContract\n  };\n};","map":{"version":3,"sources":["C:/Users/Julia/Desktop/permissioning-smart-contracts-master/permissioning-smart-contracts-master/src/context/accountData.tsx"],"names":["React","createContext","useContext","useEffect","useState","useMemo","accountRulesFactory","useNetwork","AccountDataContext","undefined","loadAccountData","accountRulesContract","setAccountList","setAccountReadOnly","functions","isReadOnly","then","getSize","listSize","listElementsPromises","i","gt","push","getByIndex","Promise","all","responses","map","address","AccountDataProvider","props","accountList","accountReadOnly","setAccountRulesContract","value","accountIngressContract","contract","removeAllListeners","on","success","account","event","useAccountData","context","Error","formattedAccountList","identifier","toLowerCase","status","reverse","dataReady","allowlist"],"mappings":"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","sourcesContent":["import React, { createContext, useContext, useEffect, useState, useMemo } from 'react';\nimport { AccountRules } from '../chain/@types/AccountRules';\nimport { accountRulesFactory } from '../chain/contracts/AccountRules';\nimport { useNetwork } from './network';\n\ntype Account = { address: string };\n\ntype ContextType =\n  | {\n      accountList: Account[];\n      setAccountList: React.Dispatch<React.SetStateAction<Account[]>>;\n      accountReadOnly?: boolean;\n      setAccountReadOnly: React.Dispatch<React.SetStateAction<boolean | undefined>>;\n      accountRulesContract?: AccountRules;\n      setAccountRulesContract: React.Dispatch<React.SetStateAction<AccountRules | undefined>>;\n    }\n  | undefined;\n\nconst AccountDataContext = createContext<ContextType>(undefined);\n\nconst loadAccountData = (\n  accountRulesContract: AccountRules | undefined,\n  setAccountList: (account: Account[]) => void,\n  setAccountReadOnly: (readOnly?: boolean) => void\n) => {\n  if (accountRulesContract === undefined) {\n    setAccountList([]);\n    setAccountReadOnly(undefined);\n  } else {\n    accountRulesContract.functions.isReadOnly().then(isReadOnly => setAccountReadOnly(isReadOnly));\n    accountRulesContract.functions.getSize().then(listSize => {\n      const listElementsPromises = [];\n      for (let i = 0; listSize.gt(i); i++) {\n        listElementsPromises.push(accountRulesContract.functions.getByIndex(i));\n      }\n      Promise.all(listElementsPromises).then(responses => {\n        setAccountList(responses.map(address => ({ address })));\n      });\n    });\n  }\n};\n\n/**\n * Provider for the data context that contains the account list\n * @param {Object} props Props given to the AccountDataProvider\n * @return The provider with the following value:\n *  - accountList: list of permitted accounts from Account Rules contract\n *  - setAccountList: setter for the allowlist state\n */\nexport const AccountDataProvider: React.FC<{}> = props => {\n  const [accountList, setAccountList] = useState<Account[]>([]);\n  const [accountReadOnly, setAccountReadOnly] = useState<boolean | undefined>(undefined);\n  const [accountRulesContract, setAccountRulesContract] = useState<AccountRules | undefined>(undefined);\n\n  const value = useMemo(\n    () => ({\n      accountList: accountList,\n      setAccountList: setAccountList,\n      accountReadOnly,\n      setAccountReadOnly,\n      accountRulesContract,\n      setAccountRulesContract\n    }),\n    [accountList, setAccountList, accountReadOnly, setAccountReadOnly, accountRulesContract, setAccountRulesContract]\n  );\n\n  const { accountIngressContract } = useNetwork();\n\n  useEffect(() => {\n    if (accountIngressContract === undefined) {\n      setAccountRulesContract(undefined);\n    } else {\n      accountRulesFactory(accountIngressContract).then(contract => {\n        setAccountRulesContract(contract);\n        contract.removeAllListeners('AccountAdded');\n        contract.removeAllListeners('AccountRemoved');\n        contract.on('AccountAdded', (success, account, event) => {\n          if (success) {\n            loadAccountData(contract, setAccountList, setAccountReadOnly);\n          }\n        });\n        contract.on('AccountRemoved', (success, account, event) => {\n          if (success) {\n            loadAccountData(contract, setAccountList, setAccountReadOnly);\n          }\n        });\n      });\n    }\n  }, [accountIngressContract, setAccountList, setAccountReadOnly]);\n\n  return <AccountDataContext.Provider value={value} {...props} />;\n};\n\n/**\n * Fetch the appropriate account data on chain and synchronize with it\n * @return {Object} Contains data of interest:\n *  - dataReady: true if isReadOnly and account allowlist are correctly fetched,\n *  false otherwise\n *  - userAddress: Address of the user\n *  - isReadOnly: Account contract is lock or unlock,\n *  - allowlist: list of permitted accounts from Account contract,\n */\nexport const useAccountData = () => {\n  const context = useContext(AccountDataContext);\n\n  if (!context) {\n    throw new Error('useAccountData must be used within an AccountDataProvider.');\n  }\n\n  const { accountList, setAccountList, accountReadOnly, setAccountReadOnly, accountRulesContract } = context;\n\n  useEffect(() => {\n    loadAccountData(accountRulesContract, setAccountList, setAccountReadOnly);\n  }, [accountRulesContract, setAccountList, setAccountReadOnly]);\n\n  const formattedAccountList = useMemo(() => {\n    return accountList\n      .map(account => ({\n        ...account,\n        identifier: account.address.toLowerCase(),\n        status: 'active'\n      }))\n      .reverse();\n  }, [accountList]);\n\n  const dataReady = useMemo(() => {\n    return accountRulesContract !== undefined && accountReadOnly !== undefined && accountList !== undefined;\n  }, [accountRulesContract, accountReadOnly, accountList]);\n\n  return {\n    dataReady,\n    allowlist: formattedAccountList,\n    isReadOnly: accountReadOnly,\n    accountRulesContract\n  };\n};\n"]},"metadata":{},"sourceType":"module"}