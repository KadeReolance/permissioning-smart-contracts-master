{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BN = require(\"bn.js\");\n\nexports.BN = BN;\n\nvar rlp = require(\"rlp\");\n\nexports.rlp = rlp;\n\nvar createKeccakHash = require('keccak');\n\nvar secp256k1 = require('secp256k1');\n\nexports.secp256k1 = secp256k1;\n\nvar assert = require('assert');\n\nvar createHash = require('create-hash');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar ethjsUtil = require('ethjs-util');\n\nObject.assign(exports, ethjsUtil);\n/**\n * The max integer that this VM can handle\n */\n\nexports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n/**\n * 2^256\n */\n\nexports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);\n/**\n * Keccak-256 hash of null\n */\n\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\n\nexports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\n\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\n\nexports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\n\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\n\nexports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\n\nexports.zeros = function (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\n * Returns a zero address.\n */\n\n\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = exports.zeros(addressLength);\n  return exports.bufferToHex(addr);\n};\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer|Array)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer|Array)\n */\n\n\nexports.setLengthLeft = function (msg, length, right) {\n  if (right === void 0) {\n    right = false;\n  }\n\n  var buf = exports.zeros(length);\n  msg = exports.toBuffer(msg);\n\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf);\n      return buf;\n    }\n\n    return msg.slice(0, length);\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length);\n      return buf;\n    }\n\n    return msg.slice(-length);\n  }\n};\n\nexports.setLength = exports.setLengthLeft;\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer|Array)\n * @param length the number of bytes the output should be\n * @return (Buffer|Array)\n */\n\nexports.setLengthRight = function (msg, length) {\n  return exports.setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Buffer` or an `Array`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\n\n\nexports.unpad = function (a) {\n  a = ethjsUtil.stripHexPrefix(a);\n  var first = a[0];\n\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n\n  return a;\n};\n\nexports.stripZeros = exports.unpad;\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param v the value\n */\n\nexports.toBuffer = function (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (exports.isHexString(v)) {\n        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');\n      } else {\n        v = Buffer.from(v);\n      }\n    } else if (typeof v === 'number') {\n      v = exports.intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (BN.isBN(v)) {\n      v = v.toArrayLike(Buffer);\n    } else if (v.toArray) {\n      // converts a BN to a Buffer\n      v = Buffer.from(v.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n\n  return v;\n};\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\n\n\nexports.bufferToInt = function (buf) {\n  return new BN(exports.toBuffer(buf)).toNumber();\n};\n/**\n * Converts a `Buffer` into a hex `String`.\n * @param buf `Buffer` object to convert\n */\n\n\nexports.bufferToHex = function (buf) {\n  buf = exports.toBuffer(buf);\n  return '0x' + buf.toString('hex');\n};\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\n\n\nexports.fromSigned = function (num) {\n  return new BN(num).fromTwos(256);\n};\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\n\n\nexports.toUnsigned = function (num) {\n  return Buffer.from(num.toTwos(256).toArray());\n};\n/**\n * Creates Keccak hash of the input\n * @param a The input data (Buffer|Array|String|Number)\n * @param bits The Keccak width\n */\n\n\nexports.keccak = function (a, bits) {\n  if (bits === void 0) {\n    bits = 256;\n  }\n\n  a = exports.toBuffer(a);\n  if (!bits) bits = 256;\n  return createKeccakHash(\"keccak\" + bits).update(a).digest();\n};\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer|Array|String|Number)\n */\n\n\nexports.keccak256 = function (a) {\n  return exports.keccak(a);\n};\n/**\n * Creates SHA256 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n */\n\n\nexports.sha256 = function (a) {\n  a = exports.toBuffer(a);\n  return createHash('sha256').update(a).digest();\n};\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */\n\n\nexports.ripemd160 = function (a, padded) {\n  a = exports.toBuffer(a);\n  var hash = createHash('rmd160').update(a).digest();\n\n  if (padded === true) {\n    return exports.setLength(hash, 32);\n  } else {\n    return hash;\n  }\n};\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */\n\n\nexports.rlphash = function (a) {\n  return exports.keccak(rlp.encode(a));\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  pubKey = exports.toBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n\n  assert(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return exports.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nexports.privateToPublic = function (privateKey) {\n  privateKey = exports.toBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\n\n\nexports.importPublic = function (publicKey) {\n  publicKey = exports.toBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n\n  return publicKey;\n};\n/**\n * Returns the ECDSA signature of a message hash.\n */\n\n\nexports.ecsign = function (msgHash, privateKey, chainId) {\n  var sig = secp256k1.sign(msgHash, privateKey);\n  var recovery = sig.recovery;\n  var ret = {\n    r: sig.signature.slice(0, 32),\n    s: sig.signature.slice(32, 64),\n    v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27\n  };\n  return ret;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\n\n\nexports.hashPersonalMessage = function (message) {\n  var prefix = exports.toBuffer(\"\\u0019Ethereum Signed Message:\\n\" + message.length.toString());\n  return exports.keccak(Buffer.concat([prefix, message]));\n};\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */\n\n\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\n  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);\n  var recovery = calculateSigRecovery(v, chainId);\n\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n\n  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */\n\n\nexports.toRpcSig = function (v, r, s, chainId) {\n  var recovery = calculateSigRecovery(v, chainId);\n\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  } // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n\n\n  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v)]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */\n\n\nexports.fromRpcSig = function (sig) {\n  var buf = exports.toBuffer(sig); // NOTE: with potential introduction of chainId this might need to be updated\n\n  if (buf.length !== 65) {\n    throw new Error('Invalid signature length');\n  }\n\n  var v = buf[64]; // support both versions of `eth_sign` responses\n\n  if (v < 27) {\n    v += 27;\n  }\n\n  return {\n    v: v,\n    r: buf.slice(0, 32),\n    s: buf.slice(32, 64)\n  };\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\n\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\n\n\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === exports.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n */\n\n\nexports.toChecksumAddress = function (address) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var hash = exports.keccak(address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n */\n\n\nexports.isValidChecksumAddress = function (address) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  from = exports.toBuffer(from);\n  var nonceBN = new BN(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return exports.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return exports.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = exports.toBuffer(from);\n  var saltBuf = exports.toBuffer(salt);\n  var initCodeBuf = exports.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = exports.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, exports.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\n\n\nexports.isPrecompiled = function (address) {\n  var a = exports.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\n\n\nexports.addHexPrefix = function (str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;\n};\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\n\n\nexports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\n  if (homesteadOrLater === void 0) {\n    homesteadOrLater = true;\n  }\n\n  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false;\n  }\n\n  var rBN = new BN(r);\n  var sBN = new BN(s);\n\n  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n    return false;\n  }\n\n  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\n\n\nexports.baToJSON = function (ba) {\n  if (Buffer.isBuffer(ba)) {\n    return \"0x\" + ba.toString('hex');\n  } else if (ba instanceof Array) {\n    var array = [];\n\n    for (var i = 0; i < ba.length; i++) {\n      array.push(exports.baToJSON(ba[i]));\n    }\n\n    return array;\n  }\n};\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n */\n\n\nexports.defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = []; // attach the `toJSON`\n\n  self.toJSON = function (label) {\n    if (label === void 0) {\n      label = false;\n    }\n\n    if (label) {\n      var obj_1 = {};\n\n      self._fields.forEach(function (field) {\n        obj_1[field] = \"0x\" + self[field].toString('hex');\n      });\n\n      return obj_1;\n    }\n\n    return exports.baToJSON(self.raw);\n  };\n\n  self.serialize = function serialize() {\n    return rlp.encode(self.raw);\n  };\n\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n\n    function getter() {\n      return self.raw[i];\n    }\n\n    function setter(v) {\n      v = exports.toBuffer(v);\n\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n\n      if (field.allowLess && field.length) {\n        v = exports.stripZeros(v);\n        assert(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        assert(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\n      }\n\n      self.raw[i] = v;\n    }\n\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n\n    if (field.default) {\n      self[field.name] = field.default;\n    } // attach alias\n\n\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  }); // if the constuctor is passed data\n\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\n    }\n\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      } // make sure all the items are buffers\n\n\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = exports.toBuffer(d);\n      });\n    } else if (typeof data === 'object') {\n      var keys_1 = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};\n\nfunction calculateSigRecovery(v, chainId) {\n  return chainId ? v - (2 * chainId + 35) : v - 27;\n}\n\nfunction isValidSigRecovery(recovery) {\n  return recovery === 0 || recovery === 1;\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BN = require(\"bn.js\");\nexports.BN = BN;\nvar rlp = require(\"rlp\");\nexports.rlp = rlp;\nvar createKeccakHash = require('keccak');\nvar secp256k1 = require('secp256k1');\nexports.secp256k1 = secp256k1;\nvar assert = require('assert');\nvar createHash = require('create-hash');\nvar Buffer = require('safe-buffer').Buffer;\nvar ethjsUtil = require('ethjs-util');\nObject.assign(exports, ethjsUtil);\n/**\n * The max integer that this VM can handle\n */\nexports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n/**\n * 2^256\n */\nexports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nexports.zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n    var addressLength = 20;\n    var addr = exports.zeros(addressLength);\n    return exports.bufferToHex(addr);\n};\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer|Array)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer|Array)\n */\nexports.setLengthLeft = function (msg, length, right) {\n    if (right === void 0) { right = false; }\n    var buf = exports.zeros(length);\n    msg = exports.toBuffer(msg);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\nexports.setLength = exports.setLengthLeft;\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer|Array)\n * @param length the number of bytes the output should be\n * @return (Buffer|Array)\n */\nexports.setLengthRight = function (msg, length) {\n    return exports.setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Buffer` or an `Array`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nexports.unpad = function (a) {\n    a = ethjsUtil.stripHexPrefix(a);\n    var first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\nexports.stripZeros = exports.unpad;\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param v the value\n */\nexports.toBuffer = function (v) {\n    if (!Buffer.isBuffer(v)) {\n        if (Array.isArray(v)) {\n            v = Buffer.from(v);\n        }\n        else if (typeof v === 'string') {\n            if (exports.isHexString(v)) {\n                v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');\n            }\n            else {\n                v = Buffer.from(v);\n            }\n        }\n        else if (typeof v === 'number') {\n            v = exports.intToBuffer(v);\n        }\n        else if (v === null || v === undefined) {\n            v = Buffer.allocUnsafe(0);\n        }\n        else if (BN.isBN(v)) {\n            v = v.toArrayLike(Buffer);\n        }\n        else if (v.toArray) {\n            // converts a BN to a Buffer\n            v = Buffer.from(v.toArray());\n        }\n        else {\n            throw new Error('invalid type');\n        }\n    }\n    return v;\n};\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nexports.bufferToInt = function (buf) {\n    return new BN(exports.toBuffer(buf)).toNumber();\n};\n/**\n * Converts a `Buffer` into a hex `String`.\n * @param buf `Buffer` object to convert\n */\nexports.bufferToHex = function (buf) {\n    buf = exports.toBuffer(buf);\n    return '0x' + buf.toString('hex');\n};\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nexports.fromSigned = function (num) {\n    return new BN(num).fromTwos(256);\n};\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nexports.toUnsigned = function (num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\n/**\n * Creates Keccak hash of the input\n * @param a The input data (Buffer|Array|String|Number)\n * @param bits The Keccak width\n */\nexports.keccak = function (a, bits) {\n    if (bits === void 0) { bits = 256; }\n    a = exports.toBuffer(a);\n    if (!bits)\n        bits = 256;\n    return createKeccakHash(\"keccak\" + bits)\n        .update(a)\n        .digest();\n};\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer|Array|String|Number)\n */\nexports.keccak256 = function (a) {\n    return exports.keccak(a);\n};\n/**\n * Creates SHA256 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n */\nexports.sha256 = function (a) {\n    a = exports.toBuffer(a);\n    return createHash('sha256')\n        .update(a)\n        .digest();\n};\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */\nexports.ripemd160 = function (a, padded) {\n    a = exports.toBuffer(a);\n    var hash = createHash('rmd160')\n        .update(a)\n        .digest();\n    if (padded === true) {\n        return exports.setLength(hash, 32);\n    }\n    else {\n        return hash;\n    }\n};\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */\nexports.rlphash = function (a) {\n    return exports.keccak(rlp.encode(a));\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    pubKey = exports.toBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return exports.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    privateKey = exports.toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    publicKey = exports.toBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n    }\n    return publicKey;\n};\n/**\n * Returns the ECDSA signature of a message hash.\n */\nexports.ecsign = function (msgHash, privateKey, chainId) {\n    var sig = secp256k1.sign(msgHash, privateKey);\n    var recovery = sig.recovery;\n    var ret = {\n        r: sig.signature.slice(0, 32),\n        s: sig.signature.slice(32, 64),\n        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,\n    };\n    return ret;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexports.hashPersonalMessage = function (message) {\n    var prefix = exports.toBuffer(\"\\u0019Ethereum Signed Message:\\n\" + message.length.toString());\n    return exports.keccak(Buffer.concat([prefix, message]));\n};\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\n    var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */\nexports.toRpcSig = function (v, r, s, chainId) {\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v)]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */\nexports.fromRpcSig = function (sig) {\n    var buf = exports.toBuffer(sig);\n    // NOTE: with potential introduction of chainId this might need to be updated\n    if (buf.length !== 65) {\n        throw new Error('Invalid signature length');\n    }\n    var v = buf[64];\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v: v,\n        r: buf.slice(0, 32),\n        s: buf.slice(32, 64),\n    };\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === exports.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n */\nexports.toChecksumAddress = function (address) {\n    address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n    var hash = exports.keccak(address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n */\nexports.isValidChecksumAddress = function (address) {\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    from = exports.toBuffer(from);\n    var nonceBN = new BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return exports.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return exports.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    var fromBuf = exports.toBuffer(from);\n    var saltBuf = exports.toBuffer(salt);\n    var initCodeBuf = exports.toBuffer(initCode);\n    assert(fromBuf.length === 20);\n    assert(saltBuf.length === 32);\n    var address = exports.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, exports.keccak256(initCodeBuf)]));\n    return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n    var a = exports.unpad(address);\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nexports.addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;\n};\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\n    if (homesteadOrLater === void 0) { homesteadOrLater = true; }\n    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    var rBN = new BN(r);\n    var sBN = new BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nexports.baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return \"0x\" + ba.toString('hex');\n    }\n    else if (ba instanceof Array) {\n        var array = [];\n        for (var i = 0; i < ba.length; i++) {\n            array.push(exports.baToJSON(ba[i]));\n        }\n        return array;\n    }\n};\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n */\nexports.defineProperties = function (self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function (label) {\n        if (label === void 0) { label = false; }\n        if (label) {\n            var obj_1 = {};\n            self._fields.forEach(function (field) {\n                obj_1[field] = \"0x\" + self[field].toString('hex');\n            });\n            return obj_1;\n        }\n        return exports.baToJSON(self.raw);\n    };\n    self.serialize = function serialize() {\n        return rlp.encode(self.raw);\n    };\n    fields.forEach(function (field, i) {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = exports.toBuffer(v);\n            if (v.toString('hex') === '00' && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = exports.stripZeros(v);\n                assert(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\n            }\n            else if (!(field.allowZero && v.length === 0) && field.length) {\n                assert(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter,\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter,\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\n        }\n        if (Buffer.isBuffer(data)) {\n            data = rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error('wrong number of fields in data');\n            }\n            // make sure all the items are buffers\n            data.forEach(function (d, i) {\n                self[self._fields[i]] = exports.toBuffer(d);\n            });\n        }\n        else if (typeof data === 'object') {\n            var keys_1 = Object.keys(data);\n            fields.forEach(function (field) {\n                if (keys_1.indexOf(field.name) !== -1)\n                    self[field.name] = data[field.name];\n                if (keys_1.indexOf(field.alias) !== -1)\n                    self[field.alias] = data[field.alias];\n            });\n        }\n        else {\n            throw new Error('invalid data');\n        }\n    }\n};\nfunction calculateSigRecovery(v, chainId) {\n    return chainId ? v - (2 * chainId + 35) : v - 27;\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === 0 || recovery === 1;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}