{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Julia\\\\Desktop\\\\permissioning-smart-contracts-master\\\\permissioning-smart-contracts-master\\\\src\\\\context\\\\adminData.tsx\";\n// Libs\nimport React, { createContext, useContext, useMemo, useState, useEffect } from 'react';\nimport { adminFactory } from '../chain/contracts/Admin';\nimport { useNetwork } from './network';\nimport { listenForAccountChange } from '../chain/provider';\nconst AdminDataContext = createContext(undefined);\n\nconst loadAdminData = (adminContract, setAdmins) => {\n  if (adminContract === undefined) {\n    setAdmins(undefined);\n  } else {\n    adminContract.functions.getAdmins().then(admins => {\n      setAdmins(admins);\n    });\n  }\n};\n/**\n * Provider for the data context that contains the Admin list\n * @param {Object} props Props given to the AdminDataProvider\n * @return The provider with the following value:\n *  - admins: list of Admin accounts from Admin Rules contract\n *  - setAdmins: setter for the Admin list state\n */\n\n\nexport const AdminDataProvider = props => {\n  const [admins, setAdmins] = useState(undefined);\n  const [adminContract, setAdminContract] = useState(undefined);\n  const [userAddress, setUserAddress] = useState(undefined);\n  const value = useMemo(() => ({\n    admins,\n    setAdmins,\n    adminContract,\n    setAdminContract,\n    userAddress,\n    setUserAddress\n  }), [admins, setAdmins, adminContract, setAdminContract, userAddress, setUserAddress]);\n  const {\n    accountIngressContract,\n    nodeIngressContract\n  } = useNetwork();\n  useEffect(() => {\n    const ingressContract = accountIngressContract || nodeIngressContract;\n\n    if (ingressContract === undefined) {\n      setAdminContract(undefined);\n      setUserAddress(undefined);\n    } else {\n      adminFactory(ingressContract).then(contract => {\n        setAdminContract(contract);\n        contract.removeAllListeners('AdminAdded');\n        contract.removeAllListeners('AdminRemoved');\n        contract.on('AdminAdded', (success, account, message, event) => {\n          if (success) loadAdminData(contract, setAdmins);\n        });\n        contract.on('AdminRemoved', (success, account, event) => {\n          if (success) loadAdminData(contract, setAdmins);\n        });\n      });\n      ingressContract.signer.getAddress().then(setUserAddress);\n    }\n  }, [accountIngressContract, nodeIngressContract, setAdmins, setUserAddress]);\n  useEffect(() => {\n    listenForAccountChange(setUserAddress);\n  }, [setUserAddress]);\n  return /*#__PURE__*/React.createElement(AdminDataContext.Provider, Object.assign({\n    value: value\n  }, props, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 10\n    }\n  }));\n};\n/**\n * Fetch the appropriate Admin data on chain and synchronize with it\n * @return {Object} Contains data of interest:\n *  - dataReady: true if Admin list has been correctly fetched,\n *  false otherwise\n *  - userAddress: Address of the user\n *  - isAdmin: user is an Admin,\n *  - allowlist: list of admin accounts from Admin contract,\n */\n\nexport const useAdminData = () => {\n  const context = useContext(AdminDataContext);\n\n  if (!context) {\n    throw new Error('useAdminData must be used within an AdminDataProvider.');\n  }\n\n  const {\n    admins,\n    setAdmins,\n    adminContract,\n    userAddress\n  } = context;\n  useEffect(() => {\n    loadAdminData(adminContract, setAdmins);\n  }, [adminContract, setAdmins]);\n  const formattedAdmins = useMemo(() => {\n    return admins ? admins.map(address => ({\n      address,\n      identifier: address.toLowerCase(),\n      status: 'active'\n    })).reverse() : undefined;\n  }, [admins]);\n  const dataReady = useMemo(() => adminContract !== undefined && admins !== undefined && userAddress !== undefined, [adminContract, admins, userAddress]);\n  const isAdmin = useMemo(() => dataReady && admins ? admins.includes(userAddress) : false, [dataReady, admins, userAddress]);\n  return {\n    dataReady,\n    userAddress,\n    isAdmin,\n    admins: formattedAdmins,\n    adminContract\n  };\n};","map":{"version":3,"sources":["C:/Users/Julia/Desktop/permissioning-smart-contracts-master/permissioning-smart-contracts-master/src/context/adminData.tsx"],"names":["React","createContext","useContext","useMemo","useState","useEffect","adminFactory","useNetwork","listenForAccountChange","AdminDataContext","undefined","loadAdminData","adminContract","setAdmins","functions","getAdmins","then","admins","AdminDataProvider","props","setAdminContract","userAddress","setUserAddress","value","accountIngressContract","nodeIngressContract","ingressContract","contract","removeAllListeners","on","success","account","message","event","signer","getAddress","useAdminData","context","Error","formattedAdmins","map","address","identifier","toLowerCase","status","reverse","dataReady","isAdmin","includes"],"mappings":"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","sourcesContent":["// Libs\nimport React, { createContext, useContext, useMemo, useState, useEffect } from 'react';\nimport { Admin } from '../chain/@types/Admin';\nimport { adminFactory } from '../chain/contracts/Admin';\nimport { useNetwork } from './network';\nimport { listenForAccountChange } from '../chain/provider';\n\ntype ContextType =\n  | {\n      admins?: string[];\n      setAdmins: (admins: string[] | undefined) => void;\n      adminContract?: Admin;\n      setAdminContract: React.Dispatch<React.SetStateAction<Admin | undefined>>;\n      userAddress?: string;\n      setUserAddress: React.Dispatch<React.SetStateAction<string | undefined>>;\n    }\n  | undefined;\n\nconst AdminDataContext = createContext<ContextType>(undefined);\n\nconst loadAdminData = (adminContract: Admin | undefined, setAdmins: (admins: string[] | undefined) => void) => {\n  if (adminContract === undefined) {\n    setAdmins(undefined);\n  } else {\n    adminContract.functions.getAdmins().then(admins => {\n      setAdmins(admins);\n    });\n  }\n};\n\n/**\n * Provider for the data context that contains the Admin list\n * @param {Object} props Props given to the AdminDataProvider\n * @return The provider with the following value:\n *  - admins: list of Admin accounts from Admin Rules contract\n *  - setAdmins: setter for the Admin list state\n */\nexport const AdminDataProvider: React.FC = (props: React.Props<{}>) => {\n  const [admins, setAdmins] = useState<string[] | undefined>(undefined);\n  const [adminContract, setAdminContract] = useState<Admin | undefined>(undefined);\n  const [userAddress, setUserAddress] = useState<string | undefined>(undefined);\n\n  const value = useMemo(() => ({ admins, setAdmins, adminContract, setAdminContract, userAddress, setUserAddress }), [\n    admins,\n    setAdmins,\n    adminContract,\n    setAdminContract,\n    userAddress,\n    setUserAddress\n  ]);\n\n  const { accountIngressContract, nodeIngressContract } = useNetwork();\n\n  useEffect(() => {\n    const ingressContract = accountIngressContract || nodeIngressContract;\n    if (ingressContract === undefined) {\n      setAdminContract(undefined);\n      setUserAddress(undefined);\n    } else {\n      adminFactory(ingressContract).then(contract => {\n        setAdminContract(contract);\n        contract.removeAllListeners('AdminAdded');\n        contract.removeAllListeners('AdminRemoved');\n        contract.on('AdminAdded', (success, account, message, event) => {\n          if (success) loadAdminData(contract, setAdmins);\n        });\n        contract.on('AdminRemoved', (success, account, event) => {\n          if (success) loadAdminData(contract, setAdmins);\n        });\n      });\n      ingressContract.signer.getAddress().then(setUserAddress);\n    }\n  }, [accountIngressContract, nodeIngressContract, setAdmins, setUserAddress]);\n\n  useEffect(() => {\n    listenForAccountChange(setUserAddress);\n  }, [setUserAddress]);\n\n  return <AdminDataContext.Provider value={value} {...props} />;\n};\n\n/**\n * Fetch the appropriate Admin data on chain and synchronize with it\n * @return {Object} Contains data of interest:\n *  - dataReady: true if Admin list has been correctly fetched,\n *  false otherwise\n *  - userAddress: Address of the user\n *  - isAdmin: user is an Admin,\n *  - allowlist: list of admin accounts from Admin contract,\n */\nexport const useAdminData = () => {\n  const context = useContext(AdminDataContext);\n\n  if (!context) {\n    throw new Error('useAdminData must be used within an AdminDataProvider.');\n  }\n\n  const { admins, setAdmins, adminContract, userAddress } = context;\n\n  useEffect(() => {\n    loadAdminData(adminContract, setAdmins);\n  }, [adminContract, setAdmins]);\n\n  const formattedAdmins = useMemo(() => {\n    return admins\n      ? admins\n          .map(address => ({\n            address,\n            identifier: address.toLowerCase(),\n            status: 'active'\n          }))\n          .reverse()\n      : undefined;\n  }, [admins]);\n\n  const dataReady = useMemo(() => adminContract !== undefined && admins !== undefined && userAddress !== undefined, [\n    adminContract,\n    admins,\n    userAddress\n  ]);\n\n  const isAdmin = useMemo(() => (dataReady && admins ? admins.includes(userAddress!) : false), [\n    dataReady,\n    admins,\n    userAddress\n  ]);\n\n  return {\n    dataReady,\n    userAddress,\n    isAdmin,\n    admins: formattedAdmins,\n    adminContract\n  };\n};\n"]},"metadata":{},"sourceType":"module"}