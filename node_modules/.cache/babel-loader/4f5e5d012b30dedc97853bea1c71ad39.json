{"ast":null,"code":"const ipv4Prefix = '00000000000000000000ffff';\n\nconst hexToIp = address => {\n  address = address.split('x')[1];\n  return isIpv4(address) ? getIpv4(address) : getIpv6(address);\n};\n\nconst isIpv4 = address => {\n  return address.startsWith(ipv4Prefix) && parseInt(address.substring(ipv4Prefix.length), 16) <= 0xffffffff;\n};\n\nconst getIpv4 = address => {\n  return splitAddress(address.split(ipv4Prefix)[1], 2).map(hex => {\n    return parseInt(hex, 16);\n  }).join('.');\n};\n\nconst getIpv6 = address => {\n  return splitAddress(address, 4).join(':');\n};\n\nconst splitAddress = (address, digits) => {\n  const bits = [];\n\n  while (address.length >= digits) {\n    bits.push(address.slice(0, digits));\n    address = address.slice(digits);\n  }\n\n  return bits;\n};\n\nexport default hexToIp;","map":{"version":3,"sources":["C:/Users/Julia/Desktop/permissioning-smart-contracts-master/permissioning-smart-contracts-master/src/util/ipConverter.ts"],"names":["ipv4Prefix","hexToIp","address","split","isIpv4","getIpv4","getIpv6","startsWith","parseInt","substring","length","splitAddress","map","hex","join","digits","bits","push","slice"],"mappings":"AAAA,MAAMA,UAAkB,GAAG,0BAA3B;;AAEA,MAAMC,OAAO,GAAIC,OAAD,IAAqB;AACnCA,EAAAA,OAAO,GAAGA,OAAO,CAACC,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAV;AACA,SAAOC,MAAM,CAACF,OAAD,CAAN,GAAkBG,OAAO,CAACH,OAAD,CAAzB,GAAqCI,OAAO,CAACJ,OAAD,CAAnD;AACD,CAHD;;AAKA,MAAME,MAAM,GAAIF,OAAD,IAAqB;AAClC,SAAOA,OAAO,CAACK,UAAR,CAAmBP,UAAnB,KAAkCQ,QAAQ,CAACN,OAAO,CAACO,SAAR,CAAkBT,UAAU,CAACU,MAA7B,CAAD,EAAuC,EAAvC,CAAR,IAAsD,UAA/F;AACD,CAFD;;AAIA,MAAML,OAAO,GAAIH,OAAD,IAAqB;AACnC,SAAOS,YAAY,CAACT,OAAO,CAACC,KAAR,CAAcH,UAAd,EAA0B,CAA1B,CAAD,EAA+B,CAA/B,CAAZ,CACJY,GADI,CACAC,GAAG,IAAI;AACV,WAAOL,QAAQ,CAACK,GAAD,EAAM,EAAN,CAAf;AACD,GAHI,EAIJC,IAJI,CAIC,GAJD,CAAP;AAKD,CAND;;AAQA,MAAMR,OAAO,GAAIJ,OAAD,IAAqB;AACnC,SAAOS,YAAY,CAACT,OAAD,EAAU,CAAV,CAAZ,CAAyBY,IAAzB,CAA8B,GAA9B,CAAP;AACD,CAFD;;AAIA,MAAMH,YAAY,GAAG,CAACT,OAAD,EAAkBa,MAAlB,KAAqC;AACxD,QAAMC,IAAc,GAAG,EAAvB;;AAEA,SAAOd,OAAO,CAACQ,MAAR,IAAkBK,MAAzB,EAAiC;AAC/BC,IAAAA,IAAI,CAACC,IAAL,CAAUf,OAAO,CAACgB,KAAR,CAAc,CAAd,EAAiBH,MAAjB,CAAV;AACAb,IAAAA,OAAO,GAAGA,OAAO,CAACgB,KAAR,CAAcH,MAAd,CAAV;AACD;;AACD,SAAOC,IAAP;AACD,CARD;;AAUA,eAAef,OAAf","sourcesContent":["const ipv4Prefix: string = '00000000000000000000ffff';\n\nconst hexToIp = (address: string) => {\n  address = address.split('x')[1];\n  return isIpv4(address) ? getIpv4(address) : getIpv6(address);\n};\n\nconst isIpv4 = (address: string) => {\n  return address.startsWith(ipv4Prefix) && parseInt(address.substring(ipv4Prefix.length), 16) <= 0xffffffff;\n};\n\nconst getIpv4 = (address: string) => {\n  return splitAddress(address.split(ipv4Prefix)[1], 2)\n    .map(hex => {\n      return parseInt(hex, 16);\n    })\n    .join('.');\n};\n\nconst getIpv6 = (address: string) => {\n  return splitAddress(address, 4).join(':');\n};\n\nconst splitAddress = (address: string, digits: number) => {\n  const bits: string[] = [];\n\n  while (address.length >= digits) {\n    bits.push(address.slice(0, digits));\n    address = address.slice(digits);\n  }\n  return bits;\n};\n\nexport default hexToIp;\n"]},"metadata":{},"sourceType":"module"}