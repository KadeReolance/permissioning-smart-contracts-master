{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Julia\\\\Desktop\\\\permissioning-smart-contracts-master\\\\permissioning-smart-contracts-master\\\\src\\\\context\\\\nodeData.tsx\";\n// Libs\nimport React, { createContext, useContext, useEffect, useState, useMemo } from 'react';\nimport { nodeRulesFactory } from '../chain/contracts/NodeRules';\nimport { useNetwork } from './network'; // Utils\n\nimport { paramsToIdentifier } from '../util/enodetools';\nconst DataContext = createContext(undefined);\n\nconst loadNodeData = (nodeRulesContract, setNodeList, setNodeReadOnly) => {\n  if (nodeRulesContract === undefined) {\n    setNodeList([]);\n    setNodeReadOnly(undefined);\n  } else {\n    nodeRulesContract.functions.isReadOnly().then(isReadOnly => setNodeReadOnly(isReadOnly));\n    nodeRulesContract.functions.getSize().then(listSize => {\n      const listElementPromises = [];\n\n      for (let i = 0; listSize.gt(i); i++) {\n        listElementPromises.push(nodeRulesContract.functions.getByIndex(i));\n      }\n\n      Promise.all(listElementPromises).then(responses => {\n        const updatedNodeList = responses.map(r => {\n          const withStringyPort = { ...r,\n            port: r.port.toString()\n          };\n          return { ...withStringyPort,\n            identifier: paramsToIdentifier(withStringyPort)\n          };\n        });\n        setNodeList(updatedNodeList);\n      });\n    });\n  }\n};\n/**\n * Provider for the data context that contains the node list\n * @param {Object} props Props given to the NodeDataProvider\n * @return The provider with the following value:\n *  - nodeList: list of whiteliist enode from Node Rules contract\n *  - setNodeList: setter for the list state\n */\n\n\nexport const NodeDataProvider = props => {\n  const [nodeList, setNodeList] = useState([]);\n  const [nodeReadOnly, setNodeReadOnly] = useState(undefined);\n  const [nodeRulesContract, setNodeRulesContract] = useState(undefined);\n  const value = useMemo(() => ({\n    nodeList,\n    setNodeList,\n    nodeReadOnly,\n    setNodeReadOnly,\n    nodeRulesContract,\n    setNodeRulesContract\n  }), [nodeList, setNodeList, nodeReadOnly, setNodeReadOnly, nodeRulesContract, setNodeRulesContract]);\n  const {\n    nodeIngressContract\n  } = useNetwork();\n  useEffect(() => {\n    if (nodeIngressContract === undefined) {\n      setNodeRulesContract(undefined);\n    } else {\n      nodeRulesFactory(nodeIngressContract).then(contract => {\n        setNodeRulesContract(contract);\n        contract.removeAllListeners('NodeAdded');\n        contract.removeAllListeners('NodeRemoved');\n        contract.on('NodeAdded', () => {\n          loadNodeData(contract, setNodeList, setNodeReadOnly);\n        });\n        contract.on('NodeRemoved', () => {\n          loadNodeData(contract, setNodeList, setNodeReadOnly);\n        });\n      });\n    }\n  }, [nodeIngressContract]);\n  return /*#__PURE__*/React.createElement(DataContext.Provider, Object.assign({\n    value: value\n  }, props, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 10\n    }\n  }));\n};\n/**\n * Fetch the appropriate node data on chain and synchronize with it\n * @return {Object} Contains data of interest:\n *  - dataReady: true if isReadOnly and node allowlist are correctly fetched,\n *  false otherwise\n *  - userAddress: Address of the user\n *  - isReadOnly: Node contract is lock or unlock,\n *  - allowlist: list of permitted nodes from Node contract,\n */\n\nexport const useNodeData = () => {\n  const context = useContext(DataContext);\n\n  if (!context) {\n    throw new Error('useNodeData must be used within a NodeDataProvider.');\n  }\n\n  const {\n    nodeList,\n    setNodeList,\n    nodeReadOnly,\n    setNodeReadOnly,\n    nodeRulesContract\n  } = context;\n  useEffect(() => {\n    loadNodeData(nodeRulesContract, setNodeList, setNodeReadOnly);\n  }, [nodeRulesContract, setNodeList, setNodeReadOnly]);\n  const formattedNodeList = useMemo(() => {\n    return nodeList.map(enode => ({ ...enode,\n      status: 'active'\n    })).reverse();\n  }, [nodeList]);\n  const dataReady = useMemo(() => {\n    return nodeRulesContract !== undefined && nodeReadOnly !== undefined && nodeList !== undefined;\n  }, [nodeRulesContract, nodeReadOnly, nodeList]);\n  return {\n    dataReady,\n    allowlist: formattedNodeList,\n    isReadOnly: nodeReadOnly,\n    nodeRulesContract\n  };\n};","map":{"version":3,"sources":["C:/Users/Julia/Desktop/permissioning-smart-contracts-master/permissioning-smart-contracts-master/src/context/nodeData.tsx"],"names":["React","createContext","useContext","useEffect","useState","useMemo","nodeRulesFactory","useNetwork","paramsToIdentifier","DataContext","undefined","loadNodeData","nodeRulesContract","setNodeList","setNodeReadOnly","functions","isReadOnly","then","getSize","listSize","listElementPromises","i","gt","push","getByIndex","Promise","all","responses","updatedNodeList","map","r","withStringyPort","port","toString","identifier","NodeDataProvider","props","nodeList","nodeReadOnly","setNodeRulesContract","value","nodeIngressContract","contract","removeAllListeners","on","useNodeData","context","Error","formattedNodeList","enode","status","reverse","dataReady","allowlist"],"mappings":"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","sourcesContent":["// Libs\nimport React, { createContext, useContext, useEffect, useState, useMemo } from 'react';\nimport { NodeRules } from '../chain/@types/NodeRules';\nimport { nodeRulesFactory } from '../chain/contracts/NodeRules';\nimport { useNetwork } from './network';\n\n// Utils\nimport { paramsToIdentifier, Enode as RawEnode } from '../util/enodetools';\n\ntype Enode = RawEnode & { identifier: string };\n\ntype ContextType =\n  | {\n      nodeList: Enode[];\n      setNodeList: React.Dispatch<React.SetStateAction<Enode[]>>;\n      nodeReadOnly?: boolean;\n      setNodeReadOnly: React.Dispatch<React.SetStateAction<boolean | undefined>>;\n      nodeRulesContract?: NodeRules;\n      setNodeRulesContract: React.Dispatch<React.SetStateAction<NodeRules | undefined>>;\n    }\n  | undefined;\n\nconst DataContext = createContext<ContextType>(undefined);\n\nconst loadNodeData = (\n  nodeRulesContract: NodeRules | undefined,\n  setNodeList: (account: Enode[]) => void,\n  setNodeReadOnly: (readOnly?: boolean) => void\n) => {\n  if (nodeRulesContract === undefined) {\n    setNodeList([]);\n    setNodeReadOnly(undefined);\n  } else {\n    nodeRulesContract.functions.isReadOnly().then(isReadOnly => setNodeReadOnly(isReadOnly));\n    nodeRulesContract.functions.getSize().then(listSize => {\n      const listElementPromises = [];\n      for (let i = 0; listSize.gt(i); i++) {\n        listElementPromises.push(nodeRulesContract.functions.getByIndex(i));\n      }\n      Promise.all(listElementPromises).then(responses => {\n        const updatedNodeList = responses.map(r => {\n          const withStringyPort = { ...r, port: r.port.toString() };\n          return {\n            ...withStringyPort,\n            identifier: paramsToIdentifier(withStringyPort)\n          };\n        });\n        setNodeList(updatedNodeList);\n      });\n    });\n  }\n};\n\n/**\n * Provider for the data context that contains the node list\n * @param {Object} props Props given to the NodeDataProvider\n * @return The provider with the following value:\n *  - nodeList: list of whiteliist enode from Node Rules contract\n *  - setNodeList: setter for the list state\n */\nexport const NodeDataProvider: React.FC<{}> = props => {\n  const [nodeList, setNodeList] = useState<Enode[]>([]);\n  const [nodeReadOnly, setNodeReadOnly] = useState<boolean | undefined>(undefined);\n  const [nodeRulesContract, setNodeRulesContract] = useState<NodeRules | undefined>(undefined);\n\n  const value = useMemo(\n    () => ({ nodeList, setNodeList, nodeReadOnly, setNodeReadOnly, nodeRulesContract, setNodeRulesContract }),\n    [nodeList, setNodeList, nodeReadOnly, setNodeReadOnly, nodeRulesContract, setNodeRulesContract]\n  );\n\n  const { nodeIngressContract } = useNetwork();\n\n  useEffect(() => {\n    if (nodeIngressContract === undefined) {\n      setNodeRulesContract(undefined);\n    } else {\n      nodeRulesFactory(nodeIngressContract).then(contract => {\n        setNodeRulesContract(contract);\n        contract.removeAllListeners('NodeAdded');\n        contract.removeAllListeners('NodeRemoved');\n        contract.on('NodeAdded', () => {\n          loadNodeData(contract, setNodeList, setNodeReadOnly);\n        });\n        contract.on('NodeRemoved', () => {\n          loadNodeData(contract, setNodeList, setNodeReadOnly);\n        });\n      });\n    }\n  }, [nodeIngressContract]);\n\n  return <DataContext.Provider value={value} {...props} />;\n};\n\n/**\n * Fetch the appropriate node data on chain and synchronize with it\n * @return {Object} Contains data of interest:\n *  - dataReady: true if isReadOnly and node allowlist are correctly fetched,\n *  false otherwise\n *  - userAddress: Address of the user\n *  - isReadOnly: Node contract is lock or unlock,\n *  - allowlist: list of permitted nodes from Node contract,\n */\nexport const useNodeData = () => {\n  const context = useContext(DataContext);\n  if (!context) {\n    throw new Error('useNodeData must be used within a NodeDataProvider.');\n  }\n\n  const { nodeList, setNodeList, nodeReadOnly, setNodeReadOnly, nodeRulesContract } = context;\n\n  useEffect(() => {\n    loadNodeData(nodeRulesContract, setNodeList, setNodeReadOnly);\n  }, [nodeRulesContract, setNodeList, setNodeReadOnly]);\n\n  const formattedNodeList = useMemo(() => {\n    return nodeList.map(enode => ({ ...enode, status: 'active' })).reverse();\n  }, [nodeList]);\n\n  const dataReady = useMemo(() => {\n    return nodeRulesContract !== undefined && nodeReadOnly !== undefined && nodeList !== undefined;\n  }, [nodeRulesContract, nodeReadOnly, nodeList]);\n\n  return {\n    dataReady,\n    allowlist: formattedNodeList,\n    isReadOnly: nodeReadOnly,\n    nodeRulesContract\n  };\n};\n"]},"metadata":{},"sourceType":"module"}